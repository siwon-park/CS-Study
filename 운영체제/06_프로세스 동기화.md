# 06_프로세스 동기화(Process Synchronization)

### ※ 프로세스 동기화가 필요한 이유?

- 메모리, 주소 공간을 공유하는 CPU, 프로세스가 여러 개 있는 경우 Race condition(경쟁 상태)에 놓일 가능성이 있음
- 공유 데이터의 동시 접근은 데이터 불일치 문제를 발생 시킬 수 있음

=> **따라서 일관성 유지를 위해서는 협력 프로세스 간 실행 순서를 정해주는 메커니즘이 필요함**



※ 데이터의 접근

![image](https://user-images.githubusercontent.com/93081720/164010142-bd836952-3b67-4666-a3ad-60863b7962b7.png)

----

### 1. OS에서 Race Condition은 언제 발생하는가?

※ race condition : 여러 프로세스들이 동시에 공유 데이터에 접근하는 상황(데이터의 최종 연산 결과는 마지막에 그 데이터를 다른 프로세스에 따라 달라질 수 있음)

#### 1. 프로세스가 Kernel에서 수행 중일 때 인터럽트 발생 시

#### 2. 프로세스가 시스템 콜을 하여 Kernel 모드에서 수행 중인데 Time expired에 의해 Context switch가 발생한 경우

#### 3. MultiProcessor인 경우

----

### 2. Critical Section

공유 데이터 접근 코드

- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우, 각 프로세스에는 공유 데이터를 접근하려는 코드인 critical section이 존재함
- 하나의 프로세스가 critical section에 있을 때, 다른 모든 프로세스는 critical section에 접근하지 못하게 해야함 => How? Lock/Unlock 구현

<br>

※ 프로세스의 일반적 구조

프로세스들은 수행의 동기화(Synchronize)를 위해 몇몇 변수를 공유할 수 있음 => Synchronization variable

![image](https://user-images.githubusercontent.com/93081720/163669529-507b6829-d087-496a-9f54-40bd586a63be.png)

<br>

### 3. 프로그램적 해결법 충족 요건

#### 상호 배제(Mutual Exclusion)

프로세스가 critical section부분을 수행 중이면 다른 프로세스는 critical section에 접근하면 안 됌

<br>

#### 진입(Progress)

아무도 critical section에 없는 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 들어가게 해줘야함

<br>

#### 유한 대기(Bounded Waiting)

프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가려는 횟수에 한계가 있어야함 => 영원히 기다리게되는 starvation 방지

<br>

### 4. 해결법

- peterson algorithm
- h/w적 해결법

----

## 2. Semaphore; S

※ ADT(Abstract Data Type): 추상 자료 타입

=> Object + Operation

예) 정수 + 정수에 대한 연산

<br>

세마포를 이용해서 Lock/Unlock을 구현함

#### P연산

세마포 값을 획득하는 Operation

#### V연산

사용 후 반납하는 Operation

---

### 1. Busy Waiting 방식(=Spin Lock 방식)

CPU를 계속 소모하면서 기다리는 것(특정 조건 동안 계속 While 구문을 도는 것)

Busy waiting 방식에서는 세마포는 자원의 개수의 의미를 가진다 => Counting Semaphore; Integer variable

<br>

### 2. Block & Wakeup 방식(=Sleep Lock 방식)

P 연산 => 자원을 획득하려는데 자원이 없으면 기다림

V 연산 => 자원을 사용 후 반납하려는데 잠든 프로세스가 있으면 깨움(wake up)

Binary Semaphore

=> 일반적으로 Block & Wakeup 방식이 보다 효율적임. 그 이유는 Busy waiting 보다 CPU를 덜 쓰기 때문에 자원 낭비가 적음. 그러나 항상 그런 것만은 아니고 critical section의 길이에 따라 busy waiting이 더 좋은 경우도 존재



※ Dead Lock : 둘 이상의 프로세스가 서로에 의해 충족될 수 있는 Event를 무한히 기다리는 현상

----

### Classic Problems in Process Synchronization

#### 1. 

![image](https://user-images.githubusercontent.com/93081720/165312997-4cfa6826-a5ef-4dea-958d-d1760e61bc17.png)





<br>

![image](https://user-images.githubusercontent.com/93081720/165312830-8ebbb434-ece2-4f96-95d9-79ee12665b92.png)

<br>

![image](https://user-images.githubusercontent.com/93081720/165314930-7a1a0508-171b-42a1-af89-9277e0f0222b.png)

해당 코드 상으로는 Writer는 Read가 다 빠져 나갈 때까지 기다려야하므로 Starvation이 발생할 가능성이 있음

<br>

![image](https://user-images.githubusercontent.com/93081720/165315539-79d683b6-8350-427f-861a-fc653f9e3cae.png)

<br>





---

Monitor

동시 수행중인 프로세스 사이에서 ADT의 안전한 공유를 보장하기 위한 하이 레벨 싱크로나이제이션 컨스트럭트

세마포와 달리 Lock을 걸 필요가 없어 편리함

하나의 프로세스만 모니터 안에서 활동할 수 있음(나머지 프로세스는 밖에서 큐에 대기)



세마포의 문제점

- 문제가 발생했을 시 디버깅 및 코딩하기 힘들다
- 정확성 입증이 어렵다
- 자발적인 협력이 필요하다
- 한번의 실수가 모든 시스템에 치명적인 영향을 줄 수 있다. 예) DeadLock 발생, Mutual Exclusive 원칙 깨짐 등

