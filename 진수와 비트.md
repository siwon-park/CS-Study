# 진수와 비트

## 2진수, 16진수

### 2진수

사용하는 숫자의 범위 0, 1 (2-1까지 표현)

예) 1100 => 12, 100 => 4



### 16진수

사용하는 숫자 및 문자의 범위: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F (16-1까지 표현)

16진수를 2진수로 표현할 때, 16진수의 숫자 및 문자 하나는 각각 4비트씩 표현됨(왜냐하면 15까지 표현되니까)

예) 0F97A3(16진수) => 0000 1111 1001 0111 1010 0011(2진수)



## 비트

정보를 표시하기 위한 가장 작은 단위로써 0과 1로 표시됨

컴퓨터는 모든 정보를 0과 1로 저장함

8비트 = 1바이트

### 비트 연산

- 비트 연산을 하기 위해서 십진수를 2진수로 바꾼다음 연산함
- `A (비트 연산자) B`: A를 B만큼 또는 B와 비트 연산을 실시한다는 의미
- 연산 시 자릿수가 모자라면 앞에서부터 0을 붙인 다음 자릿수를 동일하게 만들어서 연산함
  - 예) 8 & 1 => 1000과 0001에 대한 AND 비트 연산 실시 => 0

| 연산자 | 의미                   | 예시                                       |
| ------ | ---------------------- | ------------------------------------------ |
| >>     | 오른쪽 shift 비트 연산 | A >> B (A를 B만큼 오른쪽 시프트 비트 연산) |
| <<     | 왼쪽 shift 비트 연산   | A << B (A를 B만큼 왼쪽 시프트 비트 연산)   |
| &      | 비트 연산 AND          | A & B (A와 B의 AND 비트 연산)              |
| ^      | 비트 연산 XOR          | A ^ B (A와 B의 XOR 비트 연산)              |
| \|     | 비트 연산 OR           | A \| B (A와 B의 OR 비트 연산)              |
| ~      | 비트 연산 NOT          | ~A (A의 모든 비트를 반전)                  |

#### <오른쪽 shift 비트 연산> `>>`

- num >> n : num // 2^n
  - 특정 숫자를 2의 n제곱만큼 나눔(나머지는 버림)



#### <왼쪽 shift 비트 연산> `<<`

- num << n : num * 2^n
  - 특정 숫자를 2의 n제곱만큼 곱함



#### <AND 비트 연산> `&`

두 비트 모두 1인 경우에만 1이 됨. 모든 비트가 불일치한다면 그 결과는 0, 반대로 모두 일치한다면 원래 숫자 반환

- val & (1 << n) : val의 2^n의자리 비트 값이 1인지 확인(1이라면 1을 반환)
- val & ~(1 << n): 특정 위치의 비트 값을 0으로 설정함(비트 클리어)



#### <OR 비트 연산> `|`

같은 자리의 비트끼리 연산하여 두 비트의 값 중 하나만 1이어도 1이 됨

- val | (1 << n) : val의 2^n의 자리 비트값을 1로 설정



#### <XOR 비트 연산> `^`

같은 자리의 비트끼리 연산하여 두 비트의 값이 서로 같으면 0이고,  다르면 1이 됨

- val ^ (1 << n) : val의 2^n자리 비트를 바꿈(비트 토글)



#### <XOR 비트 연산> `~`

모든 자리의 비트를 반전시킴



### 보수

컴퓨터에서 0과 1로만 정수를 표현하는데, 음수를 표현하기 위해서 사용

빼기 연산을 더하기로 처리하기 위해서 사용

※ 컴퓨터에서 음수를 표현하는 방법: 1) 최상위 비트값에 1을 표기, 2) 비트를 모두 반전시킴(보수 표현)

단순 비트 반전은 1의 보수

- 1의 보수의 문제점: +0과 -0에 대한 표현에서 메모리 낭비 발생
  - +0: 000..000, -0: 111...111
- 2의 보수: 1의 보수 방법으로 표현된 값에 최하위 비트에 1을 더함. 즉, 비트 반전 후 1을 더함